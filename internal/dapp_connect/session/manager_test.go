package session_test

import (
	"crypto/ecdh"
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/marcboeker/go-duckdb/v2"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	dc "duckysigner/internal/dapp_connect"
	"duckysigner/internal/dapp_connect/session"
	"duckysigner/internal/testing/mocks"
)

var b64encoder = base64.StdEncoding
var curve = ecdh.X25519()

var _ = Describe("DApp Connect Session Manager", func() {

	Describe("NewManager()", func() {
		It("creates a new session manager with given configuration", func() {
			sessionManager := session.NewManager(
				curve,
				&session.SessionConfig{"", "", "somewhere/dc", 42, 8, "0123456789ABCDEF", 6, 2},
			)
			Expect(sessionManager.DataDir()).To(Equal(filepath.FromSlash("somewhere/dc")), "Has correct data directory")
			Expect(sessionManager.SessionLifetime()).To(Equal(42*time.Second),
				"Has correct session lifetime")
			Expect(sessionManager.ConfirmLifetime()).To(Equal(8*time.Second),
				"Has correct confirmation lifetime")
			Expect(sessionManager.ConfirmCodeCharset()).To(Equal("0123456789ABCDEF"),
				"Has correct confirmation code character set")
			Expect(sessionManager.ConfirmCodeLen()).To(Equal(uint(6)),
				"Has correct confirmation code length")
			Expect(sessionManager.ApprovalTimeout()).To(Equal(2*time.Second),
				"Has correct confirmation code length")
		})

		It("creates a new session manager with default configuration when no configuration is given", func() {
			sessionManager := session.NewManager(curve, nil)
			Expect(sessionManager.DataDir()).To(Equal(filepath.Clean(session.DefaultDataDir)),
				"Has correct data directory")
			Expect(sessionManager.SessionLifetime()).To(Equal(session.DefaultSessionLifetime),
				"Has correct session lifetime")
			Expect(sessionManager.ConfirmLifetime()).To(Equal(session.DefaultConfirmLifetime),
				"Has correct confirmation lifetime")
			Expect(sessionManager.ConfirmCodeCharset()).To(Equal(session.DefaultConfirmCodeCharset),
				"Has correct confirmation code character set")
			Expect(sessionManager.ConfirmCodeLen()).To(Equal(uint(session.DefaultConfirmCodeLen)),
				"Has correct confirmation code length")
		})
	})

	Describe("Manager.GenerateSession()", func() {
		It("generates a new session", func() {
			// Mock session key pair to be generated by also mocking the ECDH curve
			mockSessionKey := "OA7vIBYGze5Vapw/qO3iPr+F9nRnaxsWSVnViTEZ1Ag="
			mockCurve := &mocks.EcdhCurveMock{GeneratedPrivateKey: mockSessionKey}
			mockSessionKeyBytes, err := b64encoder.DecodeString(mockSessionKey)
			Expect(err).ToNot(HaveOccurred())
			mockSk, err := mockCurve.NewPrivateKey(mockSessionKeyBytes)
			Expect(err).ToNot(HaveOccurred())

			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Generating a session")
			sessionManager := session.NewManager(mockCurve, nil)
			newSession, err := sessionManager.GenerateSession(dappId, &dc.DappData{}, []string{
				"RMAZSNHVLAMY5AUWWTSDON4S2HIUV7AYY6MWWEMKYH63YLHAKLZNHQIL3A",
			})
			Expect(err).ToNot(HaveOccurred())

			By("Checking the newly created session")
			Expect(newSession.ID()).To(Equal(mockSk.PublicKey()), "Has correct session ID")
			Expect(newSession.Key()).To(Equal(mockSk), "Has correct session key")
			Expect(newSession.Expiration()).To(
				BeTemporally("~", time.Now().Add(session.DefaultSessionLifetime), time.Second),
				"Has correct expiry",
			)
			Expect(newSession.DappId()).To(Equal(dappId), "Has correct dApp ID")
		})
	})

	Describe("Manager.GetSession()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			dirName := ".test_dc_get_session"
			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("returns nil when attempting to get a session and there is no sessions file", func() {
			// NOTE: Because this `Describe` container is "Ordered", the session
			// database file is assumed to not have been created yet

			// Generate a new session ID
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := b64encoder.EncodeToString(sessionKey.PublicKey().Bytes())
			// Check that no session is returned
			retrievedSession, err := sessionManager.GetSession(sessionId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedSession).To(BeNil())
		})

		It("gets the session with the given ID if it exists", func() {
			By("Creating a session")
			testDappData := dc.DappData{
				Name:        "My DApp 1",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}
			testSession := generateAndStoreSession(sessionManager, fileEncryptKey[:], &testDappData)

			By("Attempting to retrieve created session")
			sessionId := b64encoder.EncodeToString(testSession.Key().PublicKey().Bytes())
			retrievedSession, err := sessionManager.GetSession(sessionId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if session has been retrieved")
			Expect(retrievedSession.Key()).To(Equal(testSession.Key()),
				"Retrieved session has correct key")
			Expect(retrievedSession.Expiration()).To(BeTemporally("~", testSession.Expiration(), time.Second),
				"Retrieved session has correct expiry")
			Expect(retrievedSession.EstablishedAt()).To(BeTemporally("~", testSession.EstablishedAt(), time.Second),
				"Retrieved session has correct establishment date")
			Expect(retrievedSession.DappId()).To(Equal(testSession.DappId()),
				"Retrieved session has correct dApp ID")

			retrievedSessionDappData := retrievedSession.DappData()
			Expect(retrievedSessionDappData.Name).To(Equal(testDappData.Name),
				"Retrieved session has correct dApp name")
			Expect(retrievedSessionDappData.URL).To(Equal(testDappData.URL),
				"Retrieved session has correct dApp URL")
			Expect(retrievedSessionDappData.Description).To(Equal(testDappData.Description),
				"Retrieved session has correct dApp description")
			Expect(retrievedSessionDappData.Icon).To(Equal(testDappData.Icon),
				"Retrieved session has correct dApp icon")
			Expect(retrievedSession.Addresses()).To(HaveLen(1),
				"Retrieved session has correct number of addresses in address list")
		})

		It("returns nil when attempting to get a session that does not exist", func() {
			// Generate a new session ID
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := b64encoder.EncodeToString(sessionKey.PublicKey().Bytes())
			// Check that no session is returned
			retrievedSession, err := sessionManager.GetSession(sessionId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedSession).To(BeNil())
		})
	})

	Describe("Manager.GetAllSessions()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			dirName := ".test_dc_get_all_sessions"
			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("returns an empty slice if there is no sessions file", func() {
			// NOTE: Because this `Describe` container is "Ordered", the session
			// database file is assumed to not have been created yet
			By("Attempting to retrieve all stored sessions")
			retrievedSessions, err := sessionManager.GetAllSessions(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedSessions).To(HaveLen(0))
		})

		It("gets all sessions if there are one or more stored sessions", func() {
			By("Creating session #1")
			generateAndStoreSession(sessionManager, fileEncryptKey[:], &dc.DappData{
				Name:        "My DApp 1",
				URL:         "https://example.com",
				Description: "This is the first test.",
				Icon:        "",
			})
			By("Creating session #2")
			generateAndStoreSession(sessionManager, fileEncryptKey[:], &dc.DappData{
				Name:        "My DApp 2",
				URL:         "https://example2.com",
				Description: "This is the second test.",
				Icon:        "",
			})
			By("Creating session #3")
			generateAndStoreSession(sessionManager, fileEncryptKey[:], &dc.DappData{
				Name:        "My DApp 3",
				URL:         "https://example3.com",
				Description: "This is the third test.",
				Icon:        "",
			})

			By("Attempting to retrieve all stored sessions")
			retrievedSessions, err := sessionManager.GetAllSessions(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedSessions).To(HaveLen(3))
		})
	})

	Describe("Manager.StoreSession()", func() {
		It("stores a valid and unexpired session (when database does not exist)", func() {
			dirName := ".test_dc_store_session"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := sessionKey.PublicKey()
			est := time.Now()
			exp := time.Now().Add(5 * time.Minute)
			testDappData := dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}

			By("Creating a session")
			testSession := session.New(sessionKey, dappId, exp, est, &testDappData, nil)

			By("Attempting to store session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if session is stored")
			db, err := sessionManager.OpenDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			var (
				storedSessionId  string
				storedSessionKey []byte
				storedExp        time.Time
				storedEst        time.Time
				storedDappId     string
				storedDappName   string
				storedDappURL    string
				storedDappDesc   string
				storedDappIcon   string
				storedAddrs      duckdb.Composite[[]string]
			)
			storedSessionRow := db.QueryRow(fmt.Sprintf(
				"FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) LIMIT 1;",
				dirName+"/"+sessionManager.SessionsFile(),
			))
			storedSessionRow.Scan(
				&storedSessionId, &storedSessionKey,
				&storedExp, &storedEst,
				&storedDappId,
				&storedDappName, &storedDappURL, &storedDappDesc, &storedDappIcon,
				&storedAddrs,
			)

			Expect(storedSessionId).To(Equal(b64encoder.EncodeToString(sessionId.Bytes())),
				"Stored session has correct ID")
			Expect(storedSessionKey).To(Equal(sessionKey.Bytes()),
				"Stored session has correct key")
			Expect(storedExp).To(BeTemporally("~", exp, time.Second),
				"Stored session has correct expiry")
			Expect(storedEst).To(BeTemporally("~", est, time.Second),
				"Stored session has correct establishment date")
			Expect(storedDappId).To(Equal(b64encoder.EncodeToString(dappId.Bytes())),
				"Stored session has correct dApp ID")
			Expect(storedDappName).To(Equal(testDappData.Name),
				"Stored session has correct dApp name")
			Expect(storedDappURL).To(Equal(testDappData.URL),
				"Stored session has correct dApp URL")
			Expect(storedDappDesc).To(Equal(testDappData.Description),
				"Stored session has correct dApp description")
			Expect(storedDappIcon).To(Equal(testDappData.Icon),
				"Stored session has correct dApp icon")
			Expect(storedAddrs.Get()).To(HaveLen(0),
				"Stored session has correct number of addresses")
		})

		It("can add session to a database file that already exists", func() {
			dirName := ".test_dc_store_session_exists"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			dappKey1, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId1 := dappKey1.PublicKey()
			sessionKey1, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			est1 := time.Now()
			exp1 := time.Now().Add(5 * time.Minute)
			testSession1 := session.New(sessionKey1, dappId1, exp1, est1, &dc.DappData{
				Name:        "My DApp 1",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}, nil)

			By("Storing the first session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession1, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Creating another session")
			dappKey2, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId2 := dappKey2.PublicKey()
			sessionKey2, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId2 := sessionKey2.PublicKey()
			sessionId2B64 := b64encoder.EncodeToString(sessionId2.Bytes())
			est2 := time.Now().Add(1 * time.Minute)
			exp2 := time.Now().Add(10 * time.Minute)
			testDappData := dc.DappData{
				Name:        "My DApp 2",
				URL:         "https://example.com",
				Description: "This is another test.",
				Icon:        "",
			}
			testSession2 := session.New(sessionKey2, dappId2, exp2, est2, &testDappData, nil)

			By("Attempting to store the second session")
			err = sessionManager.StoreSession(&testSession2, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if second session is stored")
			db, err := sessionManager.OpenDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			var (
				storedSessionId  string
				storedSessionKey []byte
				storedExp        time.Time
				storedEst        time.Time
				storedDappId     string
				storedDappName   string
				storedDappURL    string
				storedDappDesc   string
				storedDappIcon   string
				storedAddrs      duckdb.Composite[[]string]
			)
			storedSessionRow := db.QueryRow(
				fmt.Sprintf(
					"FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) WHERE id = ?;",
					dirName+"/"+sessionManager.SessionsFile(),
				),
				sessionId2B64,
			)
			storedSessionRow.Scan(
				&storedSessionId, &storedSessionKey,
				&storedExp, &storedEst,
				&storedDappId,
				&storedDappName, &storedDappURL, &storedDappDesc, &storedDappIcon,
				&storedAddrs,
			)

			Expect(storedSessionId).To(Equal(b64encoder.EncodeToString(sessionId2.Bytes())),
				"Stored session has correct ID")
			Expect(storedSessionKey).To(Equal(sessionKey2.Bytes()),
				"Stored session has correct key")
			Expect(storedExp).To(BeTemporally("~", exp2, time.Second),
				"Stored session has correct expiry")
			Expect(storedEst).To(BeTemporally("~", est2, time.Second),
				"Stored session has correct establishment date")
			Expect(storedDappId).To(Equal(b64encoder.EncodeToString(dappId2.Bytes())),
				"Stored session has correct dApp ID")
			Expect(storedDappName).To(Equal(testDappData.Name),
				"Stored session has correct dApp name")
			Expect(storedDappURL).To(Equal(testDappData.URL),
				"Stored session has correct dApp URL")
			Expect(storedDappDesc).To(Equal(testDappData.Description),
				"Stored session has correct dApp description")
			Expect(storedDappIcon).To(Equal(testDappData.Icon),
				"Stored session has correct dApp icon")
			Expect(storedAddrs.Get()).To(HaveLen(0),
				"Stored session has correct number of addresses")
		})

		It("stores an expired session", func() {
			dirName := ".test_dc_store_session_expired"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := sessionKey.PublicKey()
			est := time.Now().Add(-10 * time.Minute)
			exp := time.Now().Add(-5 * time.Minute)
			testDappData := dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}
			testSession := session.New(sessionKey, dappId, exp, est, &testDappData, nil)

			By("Attempting to store session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if session is stored")
			db, err := sessionManager.OpenDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			var (
				storedSessionId  string
				storedSessionKey []byte
				storedExp        time.Time
				storedEst        time.Time
				storedDappId     string
				storedDappName   string
				storedDappURL    string
				storedDappDesc   string
				storedDappIcon   string
				storedAddrs      duckdb.Composite[[]string]
			)
			storedSessionRow := db.QueryRow(fmt.Sprintf(
				"FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) LIMIT 1;",
				dirName+"/"+sessionManager.SessionsFile(),
			))
			storedSessionRow.Scan(
				&storedSessionId, &storedSessionKey,
				&storedExp, &storedEst,
				&storedDappId,
				&storedDappName, &storedDappURL, &storedDappDesc, &storedDappIcon,
				&storedAddrs,
			)

			Expect(storedSessionId).To(Equal(b64encoder.EncodeToString(sessionId.Bytes())),
				"Stored session has correct ID")
			Expect(storedSessionKey).To(Equal(sessionKey.Bytes()),
				"Stored session has correct key")
			Expect(storedExp).To(BeTemporally("~", exp, time.Second),
				"Stored session has correct expiry")
			Expect(storedEst).To(BeTemporally("~", est, time.Second),
				"Stored session has correct establishment date")
			Expect(storedDappId).To(Equal(b64encoder.EncodeToString(dappId.Bytes())),
				"Stored session has correct dApp ID")
			Expect(storedDappName).To(Equal(testDappData.Name),
				"Stored session has correct dApp name")
			Expect(storedDappURL).To(Equal(testDappData.URL),
				"Stored session has correct dApp URL")
			Expect(storedDappDesc).To(Equal(testDappData.Description),
				"Stored session has correct dApp description")
			Expect(storedDappIcon).To(Equal(testDappData.Icon),
				"Stored session has correct dApp icon")
			Expect(storedAddrs.Get()).To(HaveLen(0),
				"Stored session has correct number of addresses")
		})

		It("fails when no session is given", func() {
			dirName := ".test_dc_store_no_session_fail"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Attempting to store (non)session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err := sessionManager.StoreSession(nil, fileEncryptKey[:])
			Expect(err).To(MatchError(session.NoSessionGivenErrMsg))
		})

		It("fails to store a session without a session key", func() {
			dirName := ".test_dc_store_session_key_fail"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()
			est := time.Now()
			exp := time.Now().Add(5 * time.Minute)
			testSession := session.New(nil, dappId, exp, est, &dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}, nil)

			By("Attempting to store session with no session key")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession, fileEncryptKey[:])
			Expect(err).To(MatchError(session.NoSessionKeyGivenErrMsg))
		})

		It("fails to store a session with an ID that is already stored", func() {
			dirName := ".test_dc_store_session_again_fail"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			dappKey1, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId1 := dappKey1.PublicKey()
			sessionKey1, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			est1 := time.Now()
			exp1 := time.Now().Add(5 * time.Minute)
			testSession1 := session.New(sessionKey1, dappId1, exp1, est1, &dc.DappData{
				Name:        "My DApp 1",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}, nil)

			By("Storing the session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession1, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Attempt to store the session again")
			err = sessionManager.StoreSession(&testSession1, fileEncryptKey[:])
			Expect(err).To(MatchError(session.SessionExistsErrMsg))
		})

		It("fails to store a session without a dApp ID", func() {
			dirName := ".test_dc_store_session_dapp_id_fail"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			est := time.Now()
			exp := time.Now().Add(5 * time.Minute)
			testSession := session.New(sessionKey, nil, exp, est, &dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}, nil)

			By("Attempting to store session with no dApp ID")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession, fileEncryptKey[:])
			Expect(err).To(MatchError(session.NoDappIdGivenErrMsg))
		})
	})

	Describe("Manager.RemoveSession()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte
		var dirName = ".test_dc_remove_session"

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("fails when attempting to remove a session when sessions file does not exist", func() {
			// NOTE: Because this `Describe` container is "Ordered", the session
			// database file is assumed to not have been created yet

			// Generate a new session ID
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := b64encoder.EncodeToString(sessionKey.PublicKey().Bytes())
			// Check that removing the session failed
			err = sessionManager.RemoveSession(sessionId, fileEncryptKey[:])
			Expect(err).To(MatchError(session.RemoveSessionNotStoredErrMsg))
		})

		It("removes the session with the given ID if it is stored", func() {
			By("Creating a session")
			testDappData := dc.DappData{
				Name:        "My DApp 1",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}
			testSession := generateAndStoreSession(sessionManager, fileEncryptKey[:], &testDappData)

			By("Attempting to remove created session")
			sessionId := b64encoder.EncodeToString(testSession.Key().PublicKey().Bytes())
			err := sessionManager.RemoveSession(sessionId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if session has been removed")
			db, err := sessionManager.OpenDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			storedSessionRow := db.QueryRow(fmt.Sprintf(
				"FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) LIMIT 1;",
				dirName+"/"+sessionManager.SessionsFile(),
			))
			err = storedSessionRow.Scan()

			Expect(err).To(MatchError(sql.ErrNoRows), "Session is not in the database file anymore")
		})

		It("returns nil when attempting to remove a session that is not stored (and sessions file exists)", func() {
			// Generate a new session ID
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := b64encoder.EncodeToString(sessionKey.PublicKey().Bytes())
			// Check that removing the session failed
			err = sessionManager.RemoveSession(sessionId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
		})
	})

	Describe("Manager.PurgeAllSessions()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			dirName := ".test_dc_purge_all_sessions"
			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("does not fail when attempting to remove all sessions and there is sessions database file", func() {
			// NOTE: Because this `Describe` container is "Ordered", the session
			// database file is assumed to not have been created yet
			By("Attempting to remove all stored sessions")
			numRemoved, err := sessionManager.PurgeAllSessions(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(numRemoved).To(Equal(uint(0)), "No sessions were removed")
		})

		It("removes all sessions if there are one or more stored sessions", func() {
			By("Creating session #1")
			generateAndStoreSession(sessionManager, fileEncryptKey[:], &dc.DappData{
				Name:        "My DApp 1",
				URL:         "https://example.com",
				Description: "This is the first test.",
				Icon:        "",
			})
			By("Creating session #2")
			generateAndStoreSession(sessionManager, fileEncryptKey[:], &dc.DappData{
				Name:        "My DApp 2",
				URL:         "https://example2.com",
				Description: "This is the second test.",
				Icon:        "",
			})
			By("Creating session #3")
			generateAndStoreSession(sessionManager, fileEncryptKey[:], &dc.DappData{
				Name:        "My DApp 3",
				URL:         "https://example3.com",
				Description: "This is the third test.",
				Icon:        "",
			})

			By("Attempting to remove all stored sessions")
			numRemoved, err := sessionManager.PurgeAllSessions(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(numRemoved).To(Equal(uint(3)), "All sessions were removed")
		})
	})

	Describe("Manager.PurgeExpiredSessions()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte
		var dirName = ".test_dc_purge_invalid_sessions"

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("does not fail when attempting to purge invalid sessions and there are no stored sessions", func() {
			// NOTE: Because this `Describe` container is "Ordered", the session
			// database file is assumed to not have been created yet
			By("Attempting to remove all stored sessions")
			numRemoved, err := sessionManager.PurgeExpiredSessions(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(numRemoved).To(Equal(uint(0)))
		})

		It("removes all expired stored sessions", func() {
			By("Creating session #1 (expired session)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			testSession := session.New(
				sessionKey,
				dappKey.PublicKey(),
				time.Now().Add(-5*time.Minute).UTC(),
				time.Now(),
				&dc.DappData{
					Name:        "My DApp 1",
					URL:         "https://example.com",
					Description: "This is the first test.",
					Icon:        "",
				},
				nil,
			)
			sessionManager.StoreSession(&testSession, fileEncryptKey[:])
			By("Creating session #2 (valid session)")
			generateAndStoreSession(sessionManager, fileEncryptKey[:], &dc.DappData{
				Name:        "My DApp 2",
				URL:         "https://example2.com",
				Description: "This is the second test.",
				Icon:        "",
			})
			By("Creating session #3 (valid session)")
			generateAndStoreSession(sessionManager, fileEncryptKey[:], &dc.DappData{
				Name:        "My DApp 3",
				URL:         "https://example3.com",
				Description: "This is the third test.",
				Icon:        "",
			})

			By("Attempting to remove all expired stored sessions")
			numRemoved, err := sessionManager.PurgeExpiredSessions(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(numRemoved).To(Equal(uint(1)), "Expired session was removed")

			By("Checking the expired sessions is removed")
			db, err := sessionManager.OpenDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			removedSessionRow := db.QueryRow(fmt.Sprintf(
				"SELECT id FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) WHERE id = ?;",
				dirName+"/"+sessionManager.SessionsFile(),
			), b64encoder.EncodeToString(sessionKey.PublicKey().Bytes()))
			var retrievedSessionId string
			err = removedSessionRow.Scan(&retrievedSessionId)
			Expect(err).To(MatchError(sql.ErrNoRows), "Expired session is not in the database file anymore")
		})

		It("does not fail when attempting to purge invalid sessions and there are no invalid stored sessions", func() {
			By("Attempting to remove all stored sessions")
			numRemoved, err := sessionManager.PurgeExpiredSessions(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(numRemoved).To(Equal(uint(0)))
		})
	})

	Describe("Manager.EstablishSession()", func() {
		It("returns an established session if confirmation is valid", func() {
			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Generating a confirmation")
			sessionManager := session.NewManager(curve, nil)
			confirm, err := sessionManager.GenerateConfirmation(dappId)
			Expect(err).ToNot(HaveOccurred())

			By("Generating a confirmation token")
			token, err := confirm.GenerateTokenString()
			Expect(err).ToNot(HaveOccurred())

			By("Confirming session using token")
			testDappData := dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}
			newSession, err := sessionManager.EstablishSession(
				token, confirm.Code(), confirm.Key(), &testDappData, nil,
			)
			Expect(err).ToNot(HaveOccurred())

			By("Checking confirmed (established) session")
			Expect(newSession.Key()).To(Equal(confirm.SessionKey()), "Has correct session key")
			Expect(newSession.Expiration()).To(
				BeTemporally("~", time.Now().Add(session.DefaultSessionLifetime), time.Second),
				"Has correct expiry",
			)
			Expect(newSession.EstablishedAt()).To(
				BeTemporally("~", time.Now(), time.Second),
				"Has correct established-at date-time",
			)
			Expect(newSession.DappId()).To(Equal(dappId), "Has correct dApp ID")

			newSessionDappData := newSession.DappData()
			Expect(newSessionDappData.Name).To(Equal(testDappData.Name),
				"Retrieved session has correct dApp name")
			Expect(newSessionDappData.URL).To(Equal(testDappData.URL),
				"Retrieved session has correct dApp URL")
			Expect(newSessionDappData.Description).To(Equal(testDappData.Description),
				"Retrieved session has correct dApp description")
			Expect(newSessionDappData.Icon).To(Equal(testDappData.Icon),
				"Retrieved session has correct dApp icon")
		})

		It("fails when not given a confirmation token", func() {
			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Generating a confirmation")
			sessionManager := session.NewManager(curve, nil)
			confirm, err := sessionManager.GenerateConfirmation(dappId)
			Expect(err).ToNot(HaveOccurred())

			By("Attempting to confirm session without a token")
			_, err = sessionManager.EstablishSession(
				"", confirm.Code(), confirm.Key(), &dc.DappData{}, nil,
			)
			Expect(err).To(MatchError(session.NoConfirmTokenGivenErrMsg))
		})

		It("fails when the given confirmation code is incorrect", func() {
			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Generating a confirmation")
			sessionManager := session.NewManager(curve, nil)
			confirm, err := sessionManager.GenerateConfirmation(dappId)
			Expect(err).ToNot(HaveOccurred())

			By("Generating a confirmation token")
			token, err := confirm.GenerateTokenString()
			Expect(err).ToNot(HaveOccurred())

			By("Attempting to confirm session using token using incorrect confirmation code")
			_, err = sessionManager.EstablishSession(token, "XXXXX", confirm.Key(), &dc.DappData{}, nil)
			Expect(err).To(MatchError(session.WrongConfirmCodeErrMsg))
		})

		It("fails when the given confirmation key is incorrect", func() {
			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Generating a confirmation")
			sessionManager := session.NewManager(curve, nil)
			confirm, err := sessionManager.GenerateConfirmation(dappId)
			Expect(err).ToNot(HaveOccurred())

			By("Generating a confirmation token")
			token, err := confirm.GenerateTokenString()
			Expect(err).ToNot(HaveOccurred())

			By("Confirming session using token")
			testDappData := dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}
			_, err = sessionManager.EstablishSession(
				token, confirm.Code(), dappKey, &testDappData, nil,
			)
			Expect(err).To(HaveOccurred())
		})
	})

	Describe("Manager.EstablishSessionWithConfirm()", func() {
		It("returns an established session if confirmation is valid", func() {
			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Generating a confirmation")
			sessionManager := session.NewManager(curve, nil)
			confirm, err := sessionManager.GenerateConfirmation(dappId)
			Expect(err).ToNot(HaveOccurred())

			By("Confirming session using a confirmation")
			testDappData := dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}
			newSession, err := sessionManager.EstablishSessionWithConfirm(
				confirm, confirm.Code(), &testDappData, nil,
			)
			Expect(err).ToNot(HaveOccurred())

			By("Checking confirmed (established) session")
			Expect(newSession.Key()).To(Equal(confirm.SessionKey()), "Has correct session key")
			Expect(newSession.Expiration()).To(
				BeTemporally("~", time.Now().Add(session.DefaultSessionLifetime), time.Second),
				"Has correct expiry",
			)
			Expect(newSession.EstablishedAt()).To(
				BeTemporally("~", time.Now(), time.Second),
				"Has correct established-at date-time",
			)
			Expect(newSession.DappId()).To(Equal(dappId), "Has correct dApp ID")

			newSessionDappData := newSession.DappData()
			Expect(newSessionDappData.Name).To(Equal(testDappData.Name),
				"Retrieved session has correct dApp name")
			Expect(newSessionDappData.URL).To(Equal(testDappData.URL),
				"Retrieved session has correct dApp URL")
			Expect(newSessionDappData.Description).To(Equal(testDappData.Description),
				"Retrieved session has correct dApp description")
			Expect(newSessionDappData.Icon).To(Equal(testDappData.Icon),
				"Retrieved session has correct dApp icon")
		})

		It("fails when not given a confirmation", func() {
			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Generating a confirmation")
			sessionManager := session.NewManager(curve, nil)
			confirm, err := sessionManager.GenerateConfirmation(dappId)
			Expect(err).ToNot(HaveOccurred())

			By("Attempting to confirm session without a confirmation")
			_, err = sessionManager.EstablishSessionWithConfirm(
				nil, confirm.Code(), &dc.DappData{}, nil,
			)
			Expect(err).To(MatchError(session.NoConfirmGivenErrMsg))
		})

		It("fails when the given confirmation code is incorrect", func() {
			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Generating a confirmation")
			sessionManager := session.NewManager(curve, nil)
			confirm, err := sessionManager.GenerateConfirmation(dappId)
			Expect(err).ToNot(HaveOccurred())

			By("Attempting to confirm session using token using incorrect confirmation code")
			_, err = sessionManager.EstablishSessionWithConfirm(confirm, "XXXXX", &dc.DappData{}, nil)
			Expect(err).To(MatchError(session.WrongConfirmCodeErrMsg))
		})
	})

	Describe("Manager.GenerateConfirmation()", func() {
		It("generates a new confirmation", func() {
			// Mock confirmation key pair to be generated by also mocking the ECDH curve
			mockConfirmKey := "OA7vIBYGze5Vapw/qO3iPr+F9nRnaxsWSVnViTEZ1Ag="
			mockCurve := &mocks.EcdhCurveMock{GeneratedPrivateKey: mockConfirmKey}
			mockConfirmKeyBytes, err := b64encoder.DecodeString(mockConfirmKey)
			Expect(err).ToNot(HaveOccurred())
			mockSk, err := mockCurve.NewPrivateKey(mockConfirmKeyBytes)
			Expect(err).ToNot(HaveOccurred())

			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Generating a confirmation")
			sessionManager := session.NewManager(mockCurve, nil)
			newConfirm, err := sessionManager.GenerateConfirmation(dappId)
			Expect(err).ToNot(HaveOccurred())

			By("Checking the newly created confirmation")
			Expect(newConfirm.ID()).To(Equal(mockSk.PublicKey()), "Has correct confirmation ID")
			Expect(newConfirm.Key()).To(Equal(mockSk), "Has correct confirmation key")
			Expect(newConfirm.Code()).To(HaveLen(session.DefaultConfirmCodeLen))
			Expect(newConfirm.Expiration()).To(
				BeTemporally("~", time.Now().Add(session.DefaultConfirmLifetime), time.Second),
				"Has correct expiry",
			)
			Expect(newConfirm.DappId()).To(Equal(dappId), "Has correct dApp ID")
		})

		It("fails if no dApp ID is given", func() {
			By("Attempting to generate a confirmation without a dApp ID")
			sessionManager := session.NewManager(curve, nil)
			_, err := sessionManager.GenerateConfirmation(nil)
			Expect(err).To(MatchError(session.NoDappIdGivenErrMsg))
		})
	})

	Describe("Manager.GetConfirmKey()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			dirName := ".test_dc_get_confirm"
			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("returns nil when attempting to get a confirmation key and there is no confirmation keystore file", func() {
			// NOTE: Because this `Describe` container is "Ordered", the session
			// database file is assumed to not have been created yet

			// Generate a new confirmation ID
			confirmKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			confirmId := b64encoder.EncodeToString(confirmKey.PublicKey().Bytes())
			// Check that no confirmation key is returned
			retrievedConfirmKey, err := sessionManager.GetConfirmKey(confirmId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedConfirmKey).To(BeNil())
		})

		It("gets the confirmation key with the given ID if it exists", func() {
			By("Generating and storing confirmation key pair")
			confirmKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			confirmId := b64encoder.EncodeToString(confirmKey.PublicKey().Bytes())
			err = sessionManager.StoreConfirmKey(confirmKey, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Attempting to retrieve created confirmation key")
			retrievedKey, err := sessionManager.GetConfirmKey(confirmId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if confirmation key has been retrieved")
			Expect(retrievedKey).To(Equal(confirmKey), "Retrieved the correct key")
		})

		It("returns nil when attempting to get a confirmation key that does not exist", func() {
			// Generate a new confirmation ID
			confirmKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			confirmId := b64encoder.EncodeToString(confirmKey.PublicKey().Bytes())
			// Check that no confirmation key is returned
			retrievedConfirmKey, err := sessionManager.GetSession(confirmId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedConfirmKey).To(BeNil())
		})
	})

	Describe("Manager.GetAllConfirmKeys()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			dirName := ".test_dc_get_all_confirms"
			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("returns an empty slice if there is no confirmations file", func() {
			// NOTE: Because this `Describe` container is "Ordered", the session
			// database file is assumed to not have been created yet
			By("Attempting to retrieve all stored confirmation keys")
			retrievedKeys, err := sessionManager.GetAllConfirmKeys(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedKeys).To(HaveLen(0))
		})

		It("gets all confirmations if there are one or more stored confirmations", func() {
			By("Creating confirmation key #1")
			confirmKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			err = sessionManager.StoreConfirmKey(confirmKey, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Creating confirmation key #2")
			confirmKey, err = curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			err = sessionManager.StoreConfirmKey(confirmKey, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Creating confirmation key #3")
			confirmKey, err = curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			err = sessionManager.StoreConfirmKey(confirmKey, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Attempting to retrieve all stored confirmation keys")
			retrievedKeys, err := sessionManager.GetAllConfirmKeys(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedKeys).To(HaveLen(3))
		})
	})

	Describe("Manager.StoreConfirmKey()", func() {
		It("stores a confirmation key", func() {
			dirName := ".test_dc_store_confirm"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			confirmKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			confirmId := b64encoder.EncodeToString(confirmKey.PublicKey().Bytes())

			By("Attempting to store a confirmation key")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreConfirmKey(confirmKey, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if confirmation key is stored")
			db, err := sessionManager.OpenDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			var (
				storedConfirmId  string
				storedConfirmKey []byte
			)
			storedSessionRow := db.QueryRow(fmt.Sprintf(
				"FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) LIMIT 1;",
				dirName+"/"+sessionManager.ConfirmationsFile(),
			))
			storedSessionRow.Scan(&storedConfirmId, &storedConfirmKey)

			Expect(storedConfirmId).To(Equal(confirmId), "Stored confirmation key has correct ID")
			Expect(storedConfirmKey).To(Equal(confirmKey.Bytes()), "Stored the correct key")
		})

		It("fails when not given a confirmation key", func() {
			dirName := ".test_dc_store_confirm_key_fail"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Attempting to store empty (nil) confirmation key")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err := sessionManager.StoreConfirmKey(nil, fileEncryptKey[:])
			Expect(err).To(MatchError(session.NoConfirmKeyGivenErrMsg))
		})
	})

	Describe("Manager.RemoveConfirmKey()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte
		var dirName = ".test_dc_remove_confirm"

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("fails when attempting to remove a confirmation key when confirmation keystore file does not exist", func() {
			// NOTE: Because this `Describe` container is "Ordered", the session
			// database file is assumed to not have been created yet

			// Generate a new confirmation ID
			confirmKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			confirmId := b64encoder.EncodeToString(confirmKey.PublicKey().Bytes())
			// Check that removing the confirmation key failed
			err = sessionManager.RemoveConfirmKey(confirmId, fileEncryptKey[:])
			Expect(err).To(MatchError(session.RemoveConfirmKeyNotStoredErrMsg))
		})

		It("removes the confirmation key with the given ID if it exists", func() {
			By("Generating and storing confirmation key pair")
			confirmKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			confirmId := b64encoder.EncodeToString(confirmKey.PublicKey().Bytes())
			err = sessionManager.StoreConfirmKey(confirmKey, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Attempting to remove created confirmation key")
			err = sessionManager.RemoveConfirmKey(confirmId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if confirmation key has been removed")
			db, err := sessionManager.OpenDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			confirmRow := db.QueryRow(fmt.Sprintf(
				"FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) LIMIT 1;",
				dirName+"/"+sessionManager.ConfirmationsFile(),
			))
			err = confirmRow.Scan()

			Expect(err).To(MatchError(sql.ErrNoRows), "Key is not in the database file anymore")
		})

		It("fails when attempting to remove a confirmation key that does not exist", func() {
			// Generate a new confirmation ID
			confirmKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			confirmId := b64encoder.EncodeToString(confirmKey.PublicKey().Bytes())
			// Check that removing the confirmation key failed
			err = sessionManager.RemoveConfirmKey(confirmId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
		})
	})

	Describe("Manager.PurgeConfirmKeystore()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			dirName := ".test_dc_purge_all_confirms"
			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("does not fail when attempting to purge all confirmation keys and there are is confirmation keystore file", func() {
			// NOTE: Because this `Describe` container is "Ordered", the
			// confirmation keystore file is assumed to not have been created
			// yet
			By("Attempting to remove all stored confirmation keys")
			numRemoved, err := sessionManager.PurgeConfirmKeystore(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(numRemoved).To(Equal(uint(0)), "No confirmation keys were removed")
		})

		It("removes all confirmation keys if there are one or more stored confirmation keys", func() {
			By("Creating confirmation key #1")
			confirmKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			err = sessionManager.StoreConfirmKey(confirmKey, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Creating confirmation key #2")
			confirmKey, err = curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			err = sessionManager.StoreConfirmKey(confirmKey, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Creating confirmation key #3")
			confirmKey, err = curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			err = sessionManager.StoreConfirmKey(confirmKey, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Attempting to remove all stored confirmation keys")
			numRemoved, err := sessionManager.PurgeConfirmKeystore(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(numRemoved).To(Equal(uint(3)), "All keys were removed")
		})
	})
})

// sessionCleanup returns a helper function that cleans up the directory with
// the specified name, which may have been created for an instance of the
// session manager
func sessionManagerCleanup(dataDirName string) func() {
	return func() {
		// Remove test data directory
		err := os.RemoveAll(dataDirName)
		if !os.IsNotExist(err) { // If no "directory does not exist" error
			Expect(err).NotTo(HaveOccurred())
		}
	}
}

// generateAndStoreSession generates a session, sets its dApp data to the given
// dApp data, and stores it using the given session manager and file encryption
// key
func generateAndStoreSession(
	sessionManager *session.Manager,
	fileEncryptKey []byte,
	dappData *dc.DappData,
) *session.Session {
	dappKey, err := curve.GenerateKey(rand.Reader)
	Expect(err).ToNot(HaveOccurred())
	sessionKey, err := curve.GenerateKey(rand.Reader)
	Expect(err).ToNot(HaveOccurred())
	testSession := session.New(
		sessionKey,
		dappKey.PublicKey(),
		time.Now().Add(5*time.Minute),
		time.Now(),
		dappData,
		[]string{"RMAZSNHVLAMY5AUWWTSDON4S2HIUV7AYY6MWWEMKYH63YLHAKLZNHQIL3A"},
	)
	sessionManager.StoreSession(&testSession, fileEncryptKey)

	return &testSession
}
