package session_test

import (
	"crypto/ecdh"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"os"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	dc "duckysigner/internal/dapp_connect"
	"duckysigner/internal/dapp_connect/session"
	"duckysigner/internal/testing/mocks"
)

var b64encoder = base64.StdEncoding
var curve = ecdh.X25519()

var _ = FDescribe("DApp Connect Session Manager", func() {

	Describe("NewManager()", func() {
		It("creates a new session manager with given configuration", func() {
			sessionManager := session.NewManager(curve, &session.SessionConfig{"", "", "somewhere/dc", 42, 8})
			Expect(sessionManager.DataDir()).To(Equal("somewhere/dc"), "Has correct data directory")
			Expect(sessionManager.SessionLifetime()).To(Equal(42*time.Second),
				"Has correct session lifetime")
			Expect(sessionManager.ConfirmLifetime()).To(Equal(8*time.Second),
				"Has correct confirmation lifetime")
		})

		It("creates a new session manager with default configuration when no configuration is given", func() {
			sessionManager := session.NewManager(curve, nil)
			Expect(sessionManager.DataDir()).To(Equal(session.DefaultDataDir), "Has correct data directory")
			Expect(sessionManager.SessionLifetime()).To(Equal(session.DefaultSessionLifetime),
				"Has correct session lifetime")
			Expect(sessionManager.ConfirmLifetime()).To(Equal(session.DefaultConfirmLifetime),
				"Has correct confirmation lifetime")
		})
	})

	Describe("GenerateSession()", func() {
		It("generates a new session", func() {
			// Mock session key pair to be generated by also mocking the ECDH curve
			mockSessionKey := "OA7vIBYGze5Vapw/qO3iPr+F9nRnaxsWSVnViTEZ1Ag="
			mockCurve := &mocks.EcdhCurveMock{GeneratedPrivateKey: mockSessionKey}
			mockSessionKeyBytes, err := b64encoder.DecodeString(mockSessionKey)
			Expect(err).ToNot(HaveOccurred())
			mockSk, err := mockCurve.NewPrivateKey(mockSessionKeyBytes)
			Expect(err).ToNot(HaveOccurred())

			By("Generating a dApp key pair (dApp ID & key)")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()

			By("Running NewSession()")
			sessionManager := session.NewManager(mockCurve, nil)
			newSession, err := sessionManager.GenerateSession(dappId, &dc.DappData{})
			Expect(err).ToNot(HaveOccurred())

			By("Checking the newly created session")
			Expect(newSession.ID()).To(Equal(mockSk.PublicKey()), "Has correct session ID")
			Expect(newSession.Key()).To(Equal(mockSk), "Has correct session key")
			Expect(newSession.Expiration()).To(
				BeTemporally("~", time.Now().Add(session.DefaultSessionLifetime), time.Second),
				"Has correct expiry",
			)
			Expect(newSession.DappId()).To(Equal(dappId), "Has correct dApp ID")
		})
	})

	Describe("GetSession()", Ordered, func() {
		var sessionManager *session.Manager
		var fileEncryptKey [32]byte

		BeforeAll(func() {
			// Generate file encryption key
			rand.Read(fileEncryptKey[:])

			dirName := ".test_dc_get_session"
			sessionManager = session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))
		})

		It("returns nil when attempting to get a session and there is no sessions file", func() {
			// Generate a new session ID
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := b64encoder.EncodeToString(sessionKey.PublicKey().Bytes())
			// Check that no session is returned
			retrievedSession, err := sessionManager.GetSession(sessionId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedSession).To(BeNil())
		})

		It("gets the session with the given ID if it exists", func() {
			By("Creating a session")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			testDappData := dc.DappData{
				Name:        "My DApp 1",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}
			testSession := session.New(
				sessionKey,
				dappKey.PublicKey(),
				time.Now().Add(5*time.Minute),
				time.Now(),
				&testDappData,
			)
			sessionManager.StoreSession(&testSession, fileEncryptKey[:])

			By("Attempting to retrieve created session")
			sessionId := b64encoder.EncodeToString(sessionKey.PublicKey().Bytes())
			retrievedSession, err := sessionManager.GetSession(sessionId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if session has been retrieved")
			Expect(retrievedSession.Key()).To(Equal(testSession.Key()),
				"Retrieved session has correct key")
			Expect(retrievedSession.Expiration()).To(BeTemporally("~", testSession.Expiration(), time.Second),
				"Retrieved session has correct expiry")
			Expect(retrievedSession.EstablishedAt()).To(BeTemporally("~", testSession.EstablishedAt(), time.Second),
				"Retrieved session has correct establishment date")
			Expect(retrievedSession.DappId()).To(Equal(testSession.DappId()),
				"Retrieved session has correct dApp ID")

			retrievedSessionDappData := retrievedSession.DappData()
			Expect(retrievedSessionDappData.Name).To(Equal(testDappData.Name),
				"Retrieved session has correct dApp name")
			Expect(retrievedSessionDappData.URL).To(Equal(testDappData.URL),
				"Retrieved session has correct dApp URL")
			Expect(retrievedSessionDappData.Description).To(Equal(testDappData.Description),
				"Retrieved session has correct dApp description")
			Expect(retrievedSessionDappData.Icon).To(Equal(testDappData.Icon),
				"Retrieved session has correct dApp icon")
		})

		It("returns nil when attempting to get a session that does not exist", func() {
			// Generate a new session ID
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := b64encoder.EncodeToString(sessionKey.PublicKey().Bytes())
			// Check that no session is returned
			retrievedSession, err := sessionManager.GetSession(sessionId, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			Expect(retrievedSession).To(BeNil())
		})
	})

	PDescribe("GetAllSessions()", func() {
		It("gets all sessions if there are one or more stored sessions", func() {
			// TODO: Complete this
		})

		It("returns an empty slice if there are no stored sessions", func() {
			// TODO: Complete this
		})
	})

	Describe("StoreSession()", func() {
		It("stores a valid and unexpired session (when database does not exist)", func() {
			dirName := ".test_dc_store_session"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := sessionKey.PublicKey()
			est := time.Now()
			exp := time.Now().Add(5 * time.Minute)
			testDappData := dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}

			By("Creating a session")
			testSession := session.New(sessionKey, dappId, exp, est, &testDappData)

			By("Attempting to store session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if session is stored")
			db, err := sessionManager.OpenSessionsDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			var (
				storedSessionId  string
				storedSessionKey []byte
				storedExp        time.Time
				storedEst        time.Time
				storedDappId     string
				storedDappName   string
				storedDappURL    string
				storedDappDesc   string
				storedDappIcon   []byte
			)
			storedSessionRow := db.QueryRow(fmt.Sprintf(
				"FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) LIMIT 1;",
				dirName+"/"+sessionManager.SessionsFile(),
			))
			storedSessionRow.Scan(
				&storedSessionId, &storedSessionKey,
				&storedExp, &storedEst,
				&storedDappId,
				&storedDappName, &storedDappURL, &storedDappDesc, &storedDappIcon,
			)

			Expect(storedSessionId).To(Equal(b64encoder.EncodeToString(sessionId.Bytes())),
				"Stored session has correct ID")
			Expect(storedSessionKey).To(Equal(sessionKey.Bytes()),
				"Stored session has correct key")
			Expect(storedExp).To(BeTemporally("~", exp, time.Second),
				"Stored session has correct expiry")
			Expect(storedEst).To(BeTemporally("~", est, time.Second),
				"Stored session has correct establishment date")
			Expect(storedDappId).To(Equal(b64encoder.EncodeToString(dappId.Bytes())),
				"Stored session has correct dApp ID")
			Expect(storedDappName).To(Equal(testDappData.Name),
				"Stored session has correct dApp name")
			Expect(storedDappURL).To(Equal(testDappData.URL),
				"Stored session has correct dApp URL")
			Expect(storedDappDesc).To(Equal(testDappData.Description),
				"Stored session has correct dApp description")
			Expect(b64encoder.EncodeToString(storedDappIcon)).To(Equal(testDappData.Icon),
				"Stored session has correct dApp icon")
		})

		It("can add session to a database file that already exists", func() {
			dirName := ".test_dc_store_session_exists"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			dappKey1, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId1 := dappKey1.PublicKey()
			sessionKey1, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			est1 := time.Now()
			exp1 := time.Now().Add(5 * time.Minute)
			testSession1 := session.New(sessionKey1, dappId1, exp1, est1, &dc.DappData{
				Name:        "My DApp 1",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			})

			By("Storing the first session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession1, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Creating another session")
			dappKey2, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId2 := dappKey2.PublicKey()
			sessionKey2, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId2 := sessionKey2.PublicKey()
			sessionId2B64 := b64encoder.EncodeToString(sessionId2.Bytes())
			est2 := time.Now().Add(1 * time.Minute)
			exp2 := time.Now().Add(10 * time.Minute)
			testDappData := dc.DappData{
				Name:        "My DApp 2",
				URL:         "https://example.com",
				Description: "This is another test.",
				Icon:        "",
			}
			testSession2 := session.New(sessionKey2, dappId2, exp2, est2, &testDappData)

			By("Attempting to store the second session")
			err = sessionManager.StoreSession(&testSession2, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if second session is stored")
			db, err := sessionManager.OpenSessionsDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			var (
				storedSessionId  string
				storedSessionKey []byte
				storedExp        time.Time
				storedEst        time.Time
				storedDappId     string
				storedDappName   string
				storedDappURL    string
				storedDappDesc   string
				storedDappIcon   []byte
			)
			storedSessionRow := db.QueryRow(
				fmt.Sprintf(
					"FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) WHERE id = ?;",
					dirName+"/"+sessionManager.SessionsFile(),
				),
				sessionId2B64,
			)
			storedSessionRow.Scan(
				&storedSessionId, &storedSessionKey,
				&storedExp, &storedEst,
				&storedDappId,
				&storedDappName, &storedDappURL, &storedDappDesc, &storedDappIcon,
			)

			Expect(storedSessionId).To(Equal(b64encoder.EncodeToString(sessionId2.Bytes())),
				"Stored session has correct ID")
			Expect(storedSessionKey).To(Equal(sessionKey2.Bytes()),
				"Stored session has correct key")
			Expect(storedExp).To(BeTemporally("~", exp2, time.Second),
				"Stored session has correct expiry")
			Expect(storedEst).To(BeTemporally("~", est2, time.Second),
				"Stored session has correct establishment date")
			Expect(storedDappId).To(Equal(b64encoder.EncodeToString(dappId2.Bytes())),
				"Stored session has correct dApp ID")
			Expect(storedDappName).To(Equal(testDappData.Name),
				"Stored session has correct dApp name")
			Expect(storedDappURL).To(Equal(testDappData.URL),
				"Stored session has correct dApp URL")
			Expect(storedDappDesc).To(Equal(testDappData.Description),
				"Stored session has correct dApp description")
			Expect(b64encoder.EncodeToString(storedDappIcon)).To(Equal(testDappData.Icon),
				"Stored session has correct dApp icon")
		})

		It("stores an expired session", func() {
			dirName := ".test_dc_store_session_expired"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			sessionId := sessionKey.PublicKey()
			est := time.Now().Add(-10 * time.Minute)
			exp := time.Now().Add(-5 * time.Minute)
			testDappData := dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			}
			testSession := session.New(sessionKey, dappId, exp, est, &testDappData)

			By("Attempting to store session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Checking if session is stored")
			db, err := sessionManager.OpenSessionsDb(fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())
			defer db.Close()

			var (
				storedSessionId  string
				storedSessionKey []byte
				storedExp        time.Time
				storedEst        time.Time
				storedDappId     string
				storedDappName   string
				storedDappURL    string
				storedDappDesc   string
				storedDappIcon   []byte
			)
			storedSessionRow := db.QueryRow(fmt.Sprintf(
				"FROM read_parquet('%s', encryption_config = {footer_key: 'key'}) LIMIT 1;",
				dirName+"/"+sessionManager.SessionsFile(),
			))
			storedSessionRow.Scan(
				&storedSessionId, &storedSessionKey,
				&storedExp, &storedEst,
				&storedDappId,
				&storedDappName, &storedDappURL, &storedDappDesc, &storedDappIcon,
			)

			Expect(storedSessionId).To(Equal(b64encoder.EncodeToString(sessionId.Bytes())),
				"Stored session has correct ID")
			Expect(storedSessionKey).To(Equal(sessionKey.Bytes()),
				"Stored session has correct key")
			Expect(storedExp).To(BeTemporally("~", exp, time.Second),
				"Stored session has correct expiry")
			Expect(storedEst).To(BeTemporally("~", est, time.Second),
				"Stored session has correct establishment date")
			Expect(storedDappId).To(Equal(b64encoder.EncodeToString(dappId.Bytes())),
				"Stored session has correct dApp ID")
			Expect(storedDappName).To(Equal(testDappData.Name),
				"Stored session has correct dApp name")
			Expect(storedDappURL).To(Equal(testDappData.URL),
				"Stored session has correct dApp URL")
			Expect(storedDappDesc).To(Equal(testDappData.Description),
				"Stored session has correct dApp description")
			Expect(b64encoder.EncodeToString(storedDappIcon)).To(Equal(testDappData.Icon),
				"Stored session has correct dApp icon")
		})

		It("fails when no session is given", func() {
			dirName := ".test_dc_store_no_session_fail"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Attempting to store (non)session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err := sessionManager.StoreSession(nil, fileEncryptKey[:])
			Expect(err).To(MatchError(session.NoSessionGivenErrMsg))
		})

		It("fails to store a session without a session key", func() {
			dirName := ".test_dc_store_session_key_fail"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			dappKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId := dappKey.PublicKey()
			est := time.Now()
			exp := time.Now().Add(5 * time.Minute)
			testSession := session.New(nil, dappId, exp, est, &dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			})

			By("Attempting to store session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession, fileEncryptKey[:])
			Expect(err).To(MatchError(session.NoSessionKeyGivenErrMsg))
		})

		It("fails to store a session with an ID that is already stored", func() {
			dirName := ".test_dc_store_session_again_fail"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			dappKey1, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			dappId1 := dappKey1.PublicKey()
			sessionKey1, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			est1 := time.Now()
			exp1 := time.Now().Add(5 * time.Minute)
			testSession1 := session.New(sessionKey1, dappId1, exp1, est1, &dc.DappData{
				Name:        "My DApp 1",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			})

			By("Storing the session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession1, fileEncryptKey[:])
			Expect(err).ToNot(HaveOccurred())

			By("Attempt to store the session again")
			err = sessionManager.StoreSession(&testSession1, fileEncryptKey[:])
			Expect(err).To(MatchError(session.SessionExistsErrMsg))
		})

		It("fails to store a session without a dApp ID", func() {
			dirName := ".test_dc_store_session_dapp_id_fail"
			sessionManager := session.NewManager(curve, &session.SessionConfig{DataDir: dirName})
			DeferCleanup(sessionManagerCleanup(dirName))

			By("Creating a session")
			sessionKey, err := curve.GenerateKey(rand.Reader)
			Expect(err).ToNot(HaveOccurred())
			est := time.Now()
			exp := time.Now().Add(5 * time.Minute)
			testSession := session.New(sessionKey, nil, exp, est, &dc.DappData{
				Name:        "My DApp",
				URL:         "https://example.com",
				Description: "This is a test.",
				Icon:        "",
			})

			By("Attempting to store session")
			// Generate file encryption key
			var fileEncryptKey [32]byte
			rand.Read(fileEncryptKey[:])

			err = sessionManager.StoreSession(&testSession, fileEncryptKey[:])
			Expect(err).To(MatchError(session.NoDappIdGivenErrMsg))
		})
	})

	PDescribe("RemoveSession()", func() {
		It("removes the session with the given ID if it exists", func() {
			// TODO: Complete this
		})

		It("fails when attempting to remove a session that does not exist", func() {
			// TODO: Complete this
		})
	})

	PDescribe("PurgeAllSessions()", func() {
		It("removes all sessions if there are one or more stored sessions", func() {
			// TODO: Complete this
		})

		It("does not fail when attempting to purge all sessions and there are no stored sessions", func() {
			// TODO: Complete this
		})
	})

	PDescribe("PurgeInvalidSessions()", func() {
		It("removes all invalid stored sessions", func() {
			// TODO: Complete this
		})

		It("does not fail when attempting to purge invalid sessions and there are no invalid stored sessions", func() {
			// TODO: Complete this
		})

		It("does not fail when attempting to purge invalid sessions and there are no stored sessions", func() {
			// TODO: Complete this
		})
	})

	PDescribe("StoreConfirmation()", func() {
		It("stores a valid and unexpired confirmation", func() {
			// TODO: Complete this
		})

		It("stores an expired confirmation", func() {
			// TODO: Complete this
		})

		It("fails to store a confirmation without a confirmation ID", func() {
			// TODO: Complete this
		})

		It("fails to store a confirmation without a confirmation key", func() {
			// TODO: Complete this
		})
	})

	PDescribe("PurgeAllConfirmations()", func() {
		It("removes all confirmations if there are one or more stored confirmations", func() {
			// TODO: Complete this
		})

		It("does not fail when attempting to purge all confirmations and there are no stored confirmations", func() {
			// TODO: Complete this
		})
	})
})

// sessionCleanup returns a helper function that cleans up the directory with
// the specified name, which may have been created for an instance of the
// session manager
func sessionManagerCleanup(dataDirName string) func() {
	return func() {
		// Remove test data directory
		err := os.RemoveAll(dataDirName)
		if !os.IsNotExist(err) { // If no "directory does not exist" error
			Expect(err).NotTo(HaveOccurred())
		}
	}
}
