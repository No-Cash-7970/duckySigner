import algosdk from 'algosdk'
import { del as idbDel, get as idbGet, set as idbSet } from 'idb-keyval'
import hawk from 'hawk';

/** The default base URL to the wallet connect server */
export const DEFAULT_SERVER_BASE_URL = 'http://localhost:1323'
/** The endpoint path for initializing a session */
export const SESSION_INIT_ENDPOINT = '/session/init'
/** The endpoint path for confirming an initialized session */
export const SESSION_CONFIRM_ENDPOINT = '/session/confirm'
/** The endpoint path for ending a session */
export const SESSION_END_ENDPOINT = '/session/end'
/** The endpoint path for signing a transaction */
export const SIGN_TXN_ENDPOINT = '/transaction/sign'

/** The default name in storage for the connect ID/key pair */
export const DEFAULT_CONNECT_KEY_PAIR_NAME = 'dcDappKeyPair'
/** The default name in storage for the connect ID/key pair */
export const DEFAULT_SESSION_DATA_NAME = 'dcSessionData'

/** Algorithm used for cryptographic key pairs */
export const KEY_ALGORITHM = 'X25519'

/** Error message for when running certain DuckyConnect method before completely setting up the
 * DuckyConnect instance
 */
const NOT_INIT_ERR_MSG =
  'This DuckyConnect instance has not been completely set up. Run `setup()` first.'

/** Information about the dApp trying to connect to the wallet. It should be the app using this
 * library.
 */
export interface DappInfo {
  /** Name of the dApp */
  name: string
  /** URL for the dApp */
  url?: string
  /** Description of the dApp. Usually as short explanation that is shown to the user. */
  desc?: string
  /** Icon for the dApp as a data URI for an image (JPEG, PNG or SVG) */
  icon?: string
}

/** Information about an established session */
export interface SessionInfo {
  /** Session ID assigned by the connect server and given to this app (client). It is needed to make
   * authenticated requests to the connect server.
   */
  id: string
  /** The date and time this session expires */
  exp: Date
  /** The addresses of the accounts connected in this session. Typically, these are the addresses
   * that are allowed to sign things within this session.
   */
  addrs: string[]
}

/** Information needed for an initialized session to be confirmed, and therefore established */
interface SessionConfirmationInfo {
  /** Confirmation ID assigned by the connect server and given to this app (client) */
  id: string
  /** The confirmation code the user needs to manually enter into the wallet to approve the dapp's
   * connection to the wallet when confirming the session
   */
  code: string
  /** A token generated by the server and given to this app (client). It is needed to confirm the
   * session.
   */
  token: string
  /** The date and time this session confirmation expires */
  exp: Date
}

/** Information regarding a session that is to be stored into local storage */
export interface StoredSessionInfo {
  /** Base64-encoded Elliptic-curve Diffie-Hellman (ECDH) public key that is to be used to identify
   * the dApp to the DApp. It is referred to as the "dApp ID" in some other documentation. More than
   * one session may use the same connect ID-key pair.
   */
  connectId: string
  /** Information about the session */
  session: SessionInfo
  /** Information about the dapp this session is for */
  dapp: DappInfo
  /** The connect server URL. If not set, the default (localhost:1323) is used. */
  serverURL: string
}

/** Options for connecting to DuckySigner */
export interface ConnectOptions {
  /** Information about the dApp connecting to the wallet */
  dapp: DappInfo
  /** The base URL to the wallet's connect server */
  serverURL?: string
  /** Function for displaying the confirmation code. If this function throws an error, the request
   * to confirm the session will not be sent to the connect server.
   */
  confirmCodeDisplayFn?: (code: string) => void
  /** Name that is used to refer to the connect key pair (connect ID & connect key) in storage. It
   * is the non-cryptographic "key" used in the storage key-value pair (the value being the
   * cryptographic connect key pair). This only needs to be changed if there needs to be a another
   * DuckyConnect instance running at the same time.
   */
  connectKeyPairName?: string
  /** Name that is used to refer to the connect session data in storage. It is the non-cryptographic
   * "key" used in the storage key-value pair (the value being the connect session data). This only
   * needs to be changed if there needs to be a another DuckyConnect instance running at the same
   * time.
   */
  sessionDataKeyName?: string
}

/** Class for connecting to and interacting with a DuckySigner DApp Connect server */
export class DuckyConnect {
  #setupComplete: boolean = false
  #connectId: string = ''
  #baseURL: string
  #dappInfo: DappInfo
  #confirmCodeDisplayFn: (code: string) => void
  #connectKeyPairName: string
  #sessionDataKeyName: string

  constructor(options: ConnectOptions) {
    this.#baseURL = options.serverURL ?? DEFAULT_SERVER_BASE_URL
    this.#dappInfo = options.dapp
    this.#confirmCodeDisplayFn = options.confirmCodeDisplayFn
      ?? ((code: string) => alert(`Confirmation code: ${code}`))
    this.#connectKeyPairName = options.connectKeyPairName ?? DEFAULT_CONNECT_KEY_PAIR_NAME
    this.#sessionDataKeyName = options.sessionDataKeyName ?? DEFAULT_SESSION_DATA_NAME
  }

  /** Set up this instance by doing various actions, like retrieving data from storage.
   *
   * NOTE: Any method that accesses the connect key pair require this initialization.
   *
   * @returns This class instance
   */
  async setup(): Promise<DuckyConnect> {
    /*
     * This method is used to get around the fact that running asynchronous methods are not well
     * suited being in the constructor. Asynchronous methods are needed for getting and generating a
     * connect key pair.
     */

    // Set the connect key pair to whatever is in storage, or generate a key pair if there is no
    // pair in storage
    const connectKeyPair = await this.#retrieveConnectKeyPair() ?? await this.#newConnectKeyPair()
    await idbSet(this.#connectKeyPairName, connectKeyPair)

    this.#connectId = await keyToBase64(connectKeyPair.publicKey)
    this.#setupComplete = true

    return this
  }

  /** Create a new dApp connect session that can then be used for other actions (e.g. signing a
   * transaction)
   * @returns The data for the newly established session
   */
  async establishSession(): Promise<StoredSessionInfo> {
    let confirmData = await this.#initializeSession()
    let sessionData = await this.#confirmSession(confirmData)
    return await this.#storeSession(sessionData)
  }

  /** Create and initialize a new session with the dApp connect server
   * @returns Information needed to confirm the newly initialized session
   */
  async #initializeSession(): Promise<SessionConfirmationInfo> {
    if (!this.#setupComplete) {
      throw new Error(NOT_INIT_ERR_MSG)
    }

    // Make request to server
    const response = await fetch(`${this.#baseURL}${SESSION_INIT_ENDPOINT}`, {
      method: 'POST',
      body: JSON.stringify({'dapp_id': this.#connectId}),
      headers: { 'Content-Type': 'application/json' },
    })
    const respJSON = await response.json()

    if (!response.ok) {
      // NOTE: An error from the server will have a 'name' and a 'message'
      throw Error(
        `Session initialization failed. Error from server: ${respJSON.message} (${respJSON.name})`
      )
    }

    // Return session confirmation data
    return {
      id: respJSON.id,
      code: respJSON.code,
      token: respJSON.token,
      exp: new Date(respJSON.exp * 1000)
    }
  }

  /** Confirm an initialized session to complete the establishment of the session with the dApp
   * connect server
   * @param sessionConfirm Confirmation information about the initialized session. Should be what is
   *                       returned by the `#initializeSession()` method
   * @returns Information about the newly confirmed (established) session
   */
  async #confirmSession(sessionConfirm: SessionConfirmationInfo): Promise<SessionInfo> {
    if (!this.#setupComplete) {
      throw new Error(NOT_INIT_ERR_MSG)
    }

    const url = `${this.#baseURL}${SESSION_CONFIRM_ENDPOINT}`
    const reqMethod = 'POST'
    const reqContentType = 'application/json'
    const reqBody = JSON.stringify({ token: sessionConfirm.token, dapp: this.#dappInfo })

    // Create Hawk header
    const credentials: hawk.client.Credentials = {
      id: sessionConfirm.id,
      key: await deriveSharedKeyB64(
        (await this.#retrieveConnectKeyPair())!.privateKey,
        await base64ToKey(sessionConfirm.id, true), // Convert confirmation ID to public key
      ),
      algorithm: 'sha256'
    }
    const hawkHeader = hawk.client.header(url, reqMethod, {
      credentials,
      contentType: reqContentType,
      payload: reqBody,
    })

    // Show confirmation code
    this.#confirmCodeDisplayFn(sessionConfirm.code)

    // Make request to server
    const response = await fetch(url, {
      method: reqMethod,
      body: reqBody,
      headers: {
        'Content-Type': reqContentType,
        'Server-Authorization': hawkHeader.header,
      },
    })
    const respText = await response.text()
    const respJSON = JSON.parse(respText)

    // Verify server response
    const authResult = hawk.client.authenticate(
      response as any,
      credentials,
      hawkHeader.artifacts,
      { payload: respText }
    )
    // If the response is valid the authentication header is returned, otherwise no headers are
    // returned or an error is thrown
    if (Object.keys(authResult.headers).length === 0) {
      throw new Error('Server response failed verification')
    }

    if (!response.ok) {
      // NOTE: An error from the server will have a 'name' and a 'message'
      throw Error(
        `Session confirmation failed. Error from server: ${respJSON.message} (${respJSON.name})`
      )
    }

    // Return new established session data
    return {
      id: respJSON.id,
      exp: new Date(respJSON.exp * 1000),
      addrs: respJSON.addrs
    }
  }

  /** Retrieve session data from local storage
   * @returns Information about the current established session being used
   */
  async retrieveSession(): Promise<StoredSessionInfo | null> {
    const sessionData = await idbGet<StoredSessionInfo>(this.#sessionDataKeyName)
    return sessionData ?? null
  }

  /** End the current established session by contacting the server, if possible.
   * @param contactServer If there should be an attempt to contact the connect server so the wallet
   *                      knows to remove the session data it has stored on its end. It is best
   *                      practice to contact the server.
   */
  async endSession(contactServer=true) {
    if (!this.#setupComplete) {
      throw new Error(NOT_INIT_ERR_MSG)
    }

    const sessionId = (await this.retrieveSession())?.session.id

    if (contactServer && sessionId) {
      const url = `${this.#baseURL}${SESSION_END_ENDPOINT}`
      const reqMethod = 'GET'

      // Create Hawk header
      const credentials: hawk.client.Credentials = {
        id: sessionId,
        key: await deriveSharedKeyB64(
          (await this.#retrieveConnectKeyPair())!.privateKey,
          await base64ToKey(sessionId, true), // Convert session ID to public key
        ),
        algorithm: 'sha256'
      }
      const hawkHeader = hawk.client.header(url, reqMethod, { credentials })

      // Make request to server. No need to know what the server's response is this time.
      try {
        await fetch(url, {method: reqMethod, headers: {'Server-Authorization': hawkHeader.header}})
      } catch (e: any) {
        console.warn(e)
      }
    }

    // Remove session from storage
    idbDel(this.#sessionDataKeyName)
  }

  /** Store the given session information into local storage
   * @param Session information to store
   * @returns The stored session information, which includes other session related data
   */
  async #storeSession(sessionInfo: SessionInfo): Promise<StoredSessionInfo> {
    const storedInfo = {
      connectId: this.#connectId,
      session: sessionInfo,
      dapp: this.#dappInfo,
      serverURL: this.#baseURL,
    }
    await idbSet(this.#sessionDataKeyName, storedInfo)
    return storedInfo
  }

  /** Generate and store connect key pair
   *
   * Securely generate and store an X25519 Elliptic-curve Diffie-Hellman (ECDH) secret key
   * ("connect key") and its public key ("connect ID"). A connect key (or "dApp key" in other
   * documentation) is required to create and use a session. If a connect key is already stored,
   * an error is thrown.
   *
   * Using the key storage method outlined here:
   * <https://www.w3.org/TR/webcrypto/#concepts-key-storage>
   *
   * A [CryptoKey](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) object is used to
   * generate and contain the key with the `extractable` option set to `false`. The object is then
   * stored into IndexedDB, where it can be retrieved later.
   *
   * Resources about the IndexedDB key storage method:
   *
   * - [Are there any security concerns with storing private keys in browser's javascript?](https://security.stackexchange.com/a/219677)
   * - [Web Crypto API - Is a non-extractable CryptoKey in IndexedDB safe enough...?](https://stackoverflow.com/questions/52276862/)
   * - [SubtleCrypto: generateKey() method](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey)
   * - [Example of saving a CryptoKey into IndexedDB](https://gist.github.com/saulshanabrook/b74984677bccd08b028b30d9968623f5)
   *
   * @param ignoreExists Ignore if a key pair exists? If true, the existing key pair will be
   *                     overwritten with a new pair
   * @returns Connect ID and connect key as a key pair
   */
  async #newConnectKeyPair(ignoreExists=false): Promise<CryptoKeyPair> {
    // Throw error if connect key pair is already stored
    if (!ignoreExists && await this.#retrieveConnectKeyPair() !== undefined) {
      throw new KeyPairExistsError(
        `A connect key pair already exists under the name '${this.#connectKeyPairName}'`
      )
    }

    // Generate key pair
    // Some code taken from <https://asecuritysite.com/webcrypto/crypt_x25519_enc>
    const keyPair = await crypto.subtle.generateKey(
      KEY_ALGORITHM,
      false, // non-extractable (very important!)
      ['deriveBits']
    ) as CryptoKeyPair

    // Store key pair into IndexedDB
    await idbSet(this.#connectKeyPairName, keyPair)

    // Set connect ID
    this.#connectId = await keyToBase64(keyPair.publicKey)

    return keyPair
  }

  /** Get the connect key-ID pair from storage
   * @returns Stored connect ID and connect key as a key pair, `undefined` if there is no key pair
   *         stored under the given `storeName`
   */
  async #retrieveConnectKeyPair(): Promise<CryptoKeyPair|undefined> {
    const keyPair = await idbGet<CryptoKeyPair>(this.#connectKeyPairName)

    // Set connect ID if key pair was successfully retrieved
    if (keyPair) {
      this.#connectId = await keyToBase64(keyPair.publicKey)
    }

    return keyPair
  }

  /** Generate a new connect key pair and replace the stored key pair with this new one.
   *
   * WARNING: This immediately ends the current connect session.
   *
   * @param contactServer If there should be an attempt to contact the connect server so the wallet
   *                      knows to remove the session data it has stored on its end. It is best
   *                      practice to contact the server.
   */
  async refreshConnectKeyPair(contactServer=true) {
    const keyPair = await this.#newConnectKeyPair(true) // Generate new key pair
    this.#connectId = await keyToBase64(keyPair.publicKey)
    await idbSet(this.#connectKeyPairName, keyPair) // Replace stored key pair
    await this.endSession(contactServer)
  }

  /** Sign the given transaction
   * @param txn Transaction to sign
   * @param signerAddr Address of the account to use to sign the transaction, if not the sender.
   * @param promptUserFn Function to run when starting to wait for the user to sign the transaction.
   *                     Should be used to indicate to the user that the transaction is ready for
   *                     them sign.
   */
  async signTransaction(
    txn: algosdk.Transaction,
    signerAddr?: string,
    promptUserFn = () => alert('Please sign the transaction.'), // TODO: Move this into configuration
  ): Promise<algosdk.SignedTransaction> {
    if (!this.#setupComplete) {
      throw new Error(NOT_INIT_ERR_MSG)
    }

    const sessionId = (await this.retrieveSession())?.session.id

    if (!sessionId) {
      throw new NoConnectSessionError(
        'There is no valid connect session. Establish a connect session and try again.'
      )
    }

    // Transform transaction into Base64 encoded bytes
    const txnToBeSignedB46 = algosdk.bytesToBase64(txn.bytesToSign())

    const url = `${this.#baseURL}${SIGN_TXN_ENDPOINT}`
    const reqMethod = 'POST'
    const reqContentType = 'application/json'
    const reqBody = JSON.stringify({ transaction: txnToBeSignedB46, signer: signerAddr || undefined })

    // Create Hawk header
    const credentials: hawk.client.Credentials = {
      id: sessionId,
      key: await deriveSharedKeyB64(
        (await this.#retrieveConnectKeyPair())!.privateKey,
        await base64ToKey(sessionId, true), // Convert confirmation ID to public key
      ),
      algorithm: 'sha256'
    }
    const hawkHeader = hawk.client.header(url, reqMethod, {
      credentials,
      contentType: reqContentType,
      payload: reqBody,
    })

    promptUserFn()

    // Make request to server
    const response = await fetch(url, {
      method: reqMethod,
      body: reqBody,
      headers: {
        'Content-Type': reqContentType,
        'Server-Authorization': hawkHeader.header,
      },
    })
    const respText = await response.text()
    const respJSON = JSON.parse(respText)

    // Verify server response
    const authResult = hawk.client.authenticate(
      response as any,
      credentials,
      hawkHeader.artifacts,
      { payload: respText }
    )
    // If the response is valid the authentication header is returned, otherwise no headers are
    // returned or an error is thrown
    if (Object.keys(authResult.headers).length === 0) {
      throw new Error('Server response failed verification')
    }

    if (!response.ok) {
      // NOTE: An error from the server will have a 'name' and a 'message'
      throw Error(
        `Transaction signing failed. Error from server: ${respJSON.message} (${respJSON.name})`
      )
    }

    return algosdk.decodeSignedTransaction(algosdk.base64ToBytes(respJSON['signed_transaction']))
  }
}

class KeyPairExistsError extends Error {}
class NoConnectSessionError extends Error {}

/** Converts the given public key (or private key, if allowed) to a Base64-encoded string of bytes
 * @param key Cryptographic key to convert to a Base64-encoded string
 * @returns Key as an Base64-encoded string
 */
async function keyToBase64(key: CryptoKey): Promise<string> {
  if (!key.extractable) {
    throw new Error('Converting key to Base64 is not allowed')
  }

  const keyBytes = await crypto.subtle.exportKey('raw', key)

  return algosdk.bytesToBase64(new Uint8Array(keyBytes))
}

/** Derive the shared key using the given X25519 private and public keys
 * @param privateKey Secret key
 * @param publicKey Public key
 * @returns Shared key as a Base64-encoded string
 */
async function deriveSharedKeyB64(privateKey: CryptoKey, publicKey: CryptoKey): Promise<string> {
  const sharedKey = await crypto.subtle.deriveBits(
    { name: KEY_ALGORITHM, public: publicKey },
    privateKey,
    32,
  )
  return algosdk.bytesToBase64(new Uint8Array(sharedKey))
}

/** Convert a Base64-encoded key into a `CryptoKey` object
 * @param b64 Base64-encoded string to convert
 * @param extractable If the key is allowed to be extracted. Should be `true` if the key is a public
 *                    key and `false` if the key is a private key. Refer to [documentation about
 *                    `CryptoKey.extractable`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey/extractable)
 *                    for more information.
 * @returns Key as a `CryptoKey`
 */
async function base64ToKey(b64: string, extractable = false): Promise<CryptoKey> {
  const keyBytes: ArrayBuffer = new Uint8Array(algosdk.base64ToBytes(b64)).buffer
  return await crypto.subtle.importKey('raw', keyBytes, KEY_ALGORITHM, extractable, [])
}
